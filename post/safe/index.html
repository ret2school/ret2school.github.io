<!doctype html>
<html lang="en-us">
  <head>
    <title>[TRACS 2021 - RE] Coffre // ret2school</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.92.2" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="nasm" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[TRACS 2021 - RE] Coffre"/>
<meta name="twitter:description" content="Intro  Epreuve 12-3 – Coffre En tant que stagiaire vous avez accès aux locaux de la NSB. Vous allez collecter des informations dans les locaux. Un coffre est présent dans les locaux en salle rideau. Il appartient à Richard Cresus de la Tune. Essayez d’ouvrir ce coffre. Quel est l’IBAN contenu dans le coffre ? Format de la réponse : IBAN sans séparateur.
 Basically, we have to crack open an electronic safe."/>

    <meta property="og:title" content="[TRACS 2021 - RE] Coffre" />
<meta property="og:description" content="Intro  Epreuve 12-3 – Coffre En tant que stagiaire vous avez accès aux locaux de la NSB. Vous allez collecter des informations dans les locaux. Un coffre est présent dans les locaux en salle rideau. Il appartient à Richard Cresus de la Tune. Essayez d’ouvrir ce coffre. Quel est l’IBAN contenu dans le coffre ? Format de la réponse : IBAN sans séparateur.
 Basically, we have to crack open an electronic safe." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ret2school.github.io/post/safe/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-12-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-12-05T00:00:00+00:00" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://ret2school.github.io"><img class="app-header-avatar" src="/pic.jpeg" alt="nasm" /></a>
      <span class="app-header-title">ret2school</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/post/list_team/">About</a>
             - 
          
          <a class="app-header-menu-item" href="/">Home</a>
             - 
          
          <a class="app-header-menu-item" href="/tags/">Tags</a>
      </nav>
      <p>Just a bunch of french ctf players</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">[TRACS 2021 - RE] Coffre</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Dec 5, 2021
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          6 min read
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://ret2school.github.io/tags/ctf/">ctf</a>
              <a class="tag" href="https://ret2school.github.io/tags/ret2school/">ret2school</a>
              <a class="tag" href="https://ret2school.github.io/tags/tracs/">TRACS</a>
              <a class="tag" href="https://ret2school.github.io/tags/nasm/">nasm</a>
              <a class="tag" href="https://ret2school.github.io/tags/alol/">alol</a>
              <a class="tag" href="https://ret2school.github.io/tags/re/">RE</a>
              <a class="tag" href="https://ret2school.github.io/tags/irl/">IRL</a>
              <a class="tag" href="https://ret2school.github.io/tags/rand/">rand</a>
              <a class="tag" href="https://ret2school.github.io/tags/2021/">2021</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h2 id="intro">Intro</h2>
<blockquote>
<p>Epreuve 12-3 – Coffre
En tant que stagiaire vous avez accès aux locaux de la NSB. Vous allez collecter des informations dans les locaux. Un coffre est présent dans les locaux en salle rideau. Il appartient à Richard Cresus de la Tune. Essayez d’ouvrir ce coffre. Quel est l’IBAN contenu dans le coffre ? Format de la réponse : IBAN sans séparateur.</p>
</blockquote>
<p>Basically, we have to crack open an electronic safe. It&rsquo;s locked with an electromagnet and requires a pin to open, moreover it prints an id right before asking for the pin. We previously were given a link to the download page one of the safe&rsquo;s software update (<code>http://safe-locks.tracs.viarezo.fr/download</code>).</p>
<h2 id="reversing-the-custom-libcryptoso-library">Reversing the custom libcrypto.so library</h2>
<p>The software update comes in the from of a <code>.maj</code> archive that we extracted to get two <code>libcrypto.so</code> libraries (one for x86, the other one for arm64 v7). We checked if the files were equivalent by looking at their code structure, and we finally choose to reverse the x86 library (even though the safe probably used the arm one) because it was easier.</p>
<p>Firstly, we looked at how the pin was checked, more specifically at the <code>libsafe_test_passcode</code> in IDA:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">_BOOL8 <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">libsafe_test_passcode</span>(<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>a1)
{
  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> v2; <span style="color:#6272a4">// eax
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">int</span> fd; <span style="color:#6272a4">// [rsp+1Ch] [rbp-64h]
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">char</span> buf[<span style="color:#bd93f9">36</span>]; <span style="color:#6272a4">// [rsp+20h] [rbp-60h] BYREF
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">char</span> s1[<span style="color:#bd93f9">40</span>]; <span style="color:#6272a4">// [rsp+50h] [rbp-30h] BYREF
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int64</span> v6; <span style="color:#6272a4">// [rsp+78h] [rbp-8h]
</span><span style="color:#6272a4"></span>
  v6 <span style="color:#ff79c6">=</span> __readfsqword(<span style="color:#bd93f9">0x28u</span>);
  fd <span style="color:#ff79c6">=</span> open(<span style="color:#f1fa8c">&#34;.safe_db&#34;</span>, <span style="color:#bd93f9">0</span>);
  <span style="color:#ff79c6">if</span> ( fd <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">0</span> )
    <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0LL</span>;
  read(fd, buf, <span style="color:#bd93f9">0x24uLL</span>);
  close(fd);
  v2 <span style="color:#ff79c6">=</span> strlen(a1);
  sha256sum(a1, v2, s1);
  <span style="color:#ff79c6">return</span> memcmp(s1, <span style="color:#ff79c6">&amp;</span>buf[<span style="color:#bd93f9">4</span>], <span style="color:#bd93f9">0x20uLL</span>) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>;
}
</code></pre></div><p>We assume the argument is a pointer to the pin, for which we compute its <code>sha256sum</code>. And if it is equal to <code>buf[4:0x24]</code>, it means the pin correct! So we have to understand what <code>buf[4:0x24]</code> is, which is stored in the <code>.safe_db</code> file. To do so we look at the <code>libsafe_generate_new_passcode</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ff79c6">__int64</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">libsafe_generate_new_passcode</span>(<span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int8</span> <span style="color:#ff79c6">*</span>a1)
{
  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> v1; <span style="color:#6272a4">// eax
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">int</span> i; <span style="color:#6272a4">// [rsp+18h] [rbp-468h]
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">int</span> fd; <span style="color:#6272a4">// [rsp+1Ch] [rbp-464h]
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">char</span> file_content[<span style="color:#bd93f9">36</span>]; <span style="color:#6272a4">// [rsp+20h] [rbp-460h] BYREF
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">char</span> hash_rand_buf[<span style="color:#bd93f9">32</span>]; <span style="color:#6272a4">// [rsp+50h] [rbp-430h] BYREF
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">char</span> rand_buf[<span style="color:#bd93f9">1032</span>]; <span style="color:#6272a4">// [rsp+70h] [rbp-410h] BYREF
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int64</span> canary; <span style="color:#6272a4">// [rsp+478h] [rbp-8h]
</span><span style="color:#6272a4"></span>
  canary <span style="color:#ff79c6">=</span> __readfsqword(<span style="color:#bd93f9">0x28u</span>);
  v1 <span style="color:#ff79c6">=</span> time(<span style="color:#bd93f9">0LL</span>);
  srand(v1);
  memset(file_content, <span style="color:#bd93f9">0</span>, <span style="color:#ff79c6">sizeof</span>(file_content));
  <span style="color:#ff79c6">*</span>(_DWORD <span style="color:#ff79c6">*</span>)file_content <span style="color:#ff79c6">=</span> rand();
  <span style="color:#ff79c6">for</span> ( i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;=</span> <span style="color:#bd93f9">1023</span>; <span style="color:#ff79c6">++</span>i )
    rand_buf[i] <span style="color:#ff79c6">=</span> rand();
  sha256sum(rand_buf, <span style="color:#bd93f9">1024LL</span>, hash_rand_buf);
  _build_passcode((<span style="color:#ff79c6">__int64</span>)hash_rand_buf, <span style="color:#bd93f9">32LL</span>, (<span style="color:#ff79c6">__int64</span>)a1, <span style="color:#bd93f9">8LL</span>);
  sha256sum(a1, <span style="color:#bd93f9">8LL</span>, <span style="color:#ff79c6">&amp;</span>file_content[<span style="color:#bd93f9">4</span>]);
  fd <span style="color:#ff79c6">=</span> open(<span style="color:#f1fa8c">&#34;.safe_db&#34;</span>, <span style="color:#bd93f9">577</span>);
  <span style="color:#ff79c6">if</span> ( fd <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">0</span> )
    <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">1LL</span>;
  write(fd, file_content, <span style="color:#bd93f9">0x24uLL</span>);
  close(fd);
  <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0LL</span>;
}
</code></pre></div><p>The function is very basic:</p>
<ul>
<li>It takes as argument a pointer to the buffer to cipher for which we compute the hash to fill out the <code>.safe_db</code> file.</li>
<li>It initializes the PRNG with <code>time(NULL)</code> passed as an argument to<code>srand</code>. It then creates an array of <code>1024</code> random bytes with the use of <code>rand</code>.</li>
<li>Then, this array is hashed with <code>sha256sum</code> and its hash is given to the <code>_build_passcode</code> function. The result is stored in the <code>a1</code> argument.</li>
<li>The argument is hashed again and in the target file we write at <code>file_content[:4]</code> the first <code>rand</code> value and at <code>file_content[4:0x24]</code> the hash of the previous ciphered buffer.</li>
</ul>
<p>The core of the encryption algorithm is in the <code>build_passcode</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ff79c6">__int64</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">build_passcode</span>(
        <span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int8</span> <span style="color:#ff79c6">*</span>hash_rand_buf,
        <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> length_hash,
        <span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int8</span> <span style="color:#ff79c6">*</span>out,
        <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> opaque_8)
{
  <span style="color:#ff79c6">__int64</span> result; <span style="color:#6272a4">// rax
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> i; <span style="color:#6272a4">// [rsp+20h] [rbp-10h]
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> length_base; <span style="color:#6272a4">// [rsp+24h] [rbp-Ch]
</span><span style="color:#6272a4"></span>
  lenght_base <span style="color:#ff79c6">=</span> strlen(<span style="color:#f1fa8c">&#34;1234567890ABCD&#34;</span>);
  <span style="color:#ff79c6">for</span> ( i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; ; <span style="color:#ff79c6">++</span>i )
  {
    result <span style="color:#ff79c6">=</span> i;
    <span style="color:#ff79c6">if</span> ( i <span style="color:#ff79c6">&gt;=</span> opaque_8 )
      <span style="color:#ff79c6">break</span>;
    out[i] <span style="color:#ff79c6">=</span> base[hash_rand_buf[i <span style="color:#ff79c6">%</span> length_hash] <span style="color:#ff79c6">%</span> length_base];
  }
  <span style="color:#ff79c6">return</span> result;
}
</code></pre></div><p>That&rsquo;s just basically filling out the <code>out</code> buffer with <code>base[hash_rand_buf[i % length_hash] % lenght_base]</code>.</p>
<p>Now we have a good understanding of the encryption algorithm, we can take a look at what exactly the <code>id</code> printed right before the pin input is. The function that generates the <code>id</code> is <code>libsafe_get_userid</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ff79c6">__int64</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">libsafe_get_userid</span>(_DWORD <span style="color:#ff79c6">*</span>id)
{
  <span style="color:#8be9fd">int</span> fd; <span style="color:#6272a4">// [rsp+1Ch] [rbp-34h]
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">int</span> buf[<span style="color:#bd93f9">10</span>]; <span style="color:#6272a4">// [rsp+20h] [rbp-30h] BYREF
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int64</span> v4; <span style="color:#6272a4">// [rsp+48h] [rbp-8h]
</span><span style="color:#6272a4"></span>
  v4 <span style="color:#ff79c6">=</span> __readfsqword(<span style="color:#bd93f9">0x28u</span>);
  fd <span style="color:#ff79c6">=</span> open(<span style="color:#f1fa8c">&#34;.safe_db&#34;</span>, <span style="color:#bd93f9">0</span>);
  <span style="color:#ff79c6">if</span> ( fd <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">0</span> )
    <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">1LL</span>;
  read(fd, buf, <span style="color:#bd93f9">0x24uLL</span>);
  close(fd);
  <span style="color:#ff79c6">*</span>id <span style="color:#ff79c6">=</span> buf[<span style="color:#bd93f9">0</span>];
  <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0LL</span>;
}
</code></pre></div><p>The function is very basic, it opens the <code>.safe_db</code> file and initializes the <code>id</code> to the first four bytes of the file which is the first value of rand as seen in the previous functions.</p>
<h2 id="cracking-the-seed">Cracking the seed</h2>
<p>To recover the pin, we have to know what hash the hash of the pin will be compared to. To do so, we have to recover the random buffer, hash it, give it to the &ldquo;core&rdquo; encryption layer and hash what it outputs. That will be the final hash which will be compared to the hash of the pin we send. The main part of the challenge is so to recover the <code>rand</code> values, more specifically the seed given to <code>srand</code> to initialize the PRNG. We know the seed in the program is <code>time(NULL)</code>. Which means that this is a timestamp that can be bruteforced in a reasonable amount of time (the 2020 edition of the CTF was cancelled because of COVID so we took as range the date of the software update until today). The bruteforce is very fast because given we know the <code>id</code> which is the value for the first call to <code>rand</code>, we have just to ensure the first value of <code>rand</code> for the seed we bruteforce is equal to the <code>id</code> value.</p>
<p>Which gives:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#ff79c6">from</span> tqdm <span style="color:#ff79c6">import</span> tqdm
<span style="color:#ff79c6">import</span> hashlib
<span style="color:#ff79c6">from</span> ctypes <span style="color:#ff79c6">import</span> CDLL
libc <span style="color:#ff79c6">=</span> CDLL(<span style="color:#f1fa8c">&#34;libc.so.6&#34;</span>)

h <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">lambda</span> x: hashlib<span style="color:#ff79c6">.</span>sha256(x)<span style="color:#ff79c6">.</span>digest()

START_TIME   <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1605052800</span> <span style="color:#6272a4"># 2020-11-11 12:00:00 AM -&gt; known date for the software update</span>
CURRENT_TIME <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1638633346</span> <span style="color:#6272a4"># 2021-12-04  3:55:46 PM -&gt; current time</span>
PINCODE      <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x4b2e2a1c</span>

CHARSET      <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">b</span><span style="color:#f1fa8c">&#34;1234567890ABCD&#34;</span>
CHARLEN      <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">len</span>(CHARSET)

<span style="color:#ff79c6">for</span> t <span style="color:#ff79c6">in</span> tqdm(<span style="color:#8be9fd;font-style:italic">range</span>(CURRENT_TIME <span style="color:#ff79c6">-</span> START_TIME)):
    t <span style="color:#ff79c6">+=</span> START_TIME

    libc<span style="color:#ff79c6">.</span>srand(t)
    
    <span style="color:#ff79c6">if</span> PINCODE <span style="color:#ff79c6">==</span> libc<span style="color:#ff79c6">.</span>rand():

        v8 <span style="color:#ff79c6">=</span> [libc<span style="color:#ff79c6">.</span>rand() <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">0xff</span> <span style="color:#ff79c6">for</span> _ <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">range</span>(<span style="color:#bd93f9">1024</span>)]
        v8 <span style="color:#ff79c6">=</span> h(<span style="color:#8be9fd;font-style:italic">bytearray</span>(v8))

        v6 <span style="color:#ff79c6">=</span> [CHARSET[v8[i <span style="color:#ff79c6">%</span> <span style="color:#bd93f9">32</span>] <span style="color:#ff79c6">%</span> CHARLEN] <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">range</span>(<span style="color:#bd93f9">8</span>)]
        v6 <span style="color:#ff79c6">=</span> h(<span style="color:#8be9fd;font-style:italic">bytearray</span>(v6))

        <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;Timestamp: </span><span style="color:#f1fa8c">{</span>t<span style="color:#f1fa8c">=}</span><span style="color:#f1fa8c">, hash: </span><span style="color:#f1fa8c">{</span>v6<span style="color:#ff79c6">.</span>hex()<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>)
</code></pre></div><p>And when we found the right seed, we just have to generate, hash, cipher and hash again the right random buffer to get the right hash to which the hash of the pin will be compared to.</p>
<pre tabindex="0"><code>$ python3 solve.py 
 94%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▏       | 31691218/33580546 [01:29&lt;00:05, 351593.81it/s]
Timestamp: t=1636749762, hash: 88c71c0cc0950acfe3835a009f8931cee0f12ab7410538f96d058184a4c90e11
100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 33580546/33580546 [01:34&lt;00:00, 356533.87it/s]
</code></pre><h2 id="hashcat--profit">Hashcat + PROFIT</h2>
<p>Now we know the final hash to which the hash of the pin is compared to, we can just run a mask attack using hashcat with a mask of 8 hexadecimal characters in uppercase (we tried for every length up to the right size: 8).</p>
<pre tabindex="0"><code>$ hashcat -a 3 -m 1400 pincode.hash ?H?H?H?H?H?H?H?H
[skip]
88c71c0cc0950acfe3835a009f8931cee0f12ab7410538f96d058184a4c90e11:4233246D

Session..........: hashcat
Status...........: Cracked
Hash.Type........: SHA2-256
Hash.Target......: 88c71c0cc0950acfe3835a009f8931cee0f12ab7410538f96d0...c90e11
Time.Started.....: Sat Dec  5 16:52:37 2021 (7 mins, 22 secs)
Time.Estimated...: Sat Dec  5 16:59:59 2021 (0 secs)
Guess.Mask.......: ?H?H?H?H?H?H?H?H [8]
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........:  7884.8 kH/s (7.30ms) @ Accel:256 Loops:64 Thr:1 Vec:8
Recovered........: 1/1 (100.00%) Digests, 1/1 (100.00%) Salts
Progress.........: 3342925824/4294967296 (77.83%)
Rejected.........: 0/3342925824 (0.00%)
Restore.Point....: 816128/1048576 (77.83%)
Restore.Sub.#1...: Salt:0 Amplifier:0-64 Iteration:0-64
Candidates.#1....: 1234515D -&gt; EBCF585D
</code></pre><p>The challenge was pretty funny because of the IRL part, and because we solved it together (<a href="https://github.com/n4sm">nasm</a> and <a href="https://twitter.com/yarienkiva">Alol</a>).</p>
<p>Authors: <a href="https://github.com/n4sm">nasm</a> and <a href="https://twitter.com/yarienkiva">Alol</a>.</p>
<h2 id="annexes">Annexes</h2>
<p><img src="https://ret2school.github.io/images/coffre.jpg" alt="The safe"></p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
